{"meta":{"title":"Wan Wenxiu","subtitle":null,"description":null,"author":"Wan Wenxiu","url":"//www.wanwenxiu.com"},"posts":[{"title":"商城模块后台及APP操作路程记录","slug":"商城模块后台及APP流程","date":"2017-06-13T06:50:00.000Z","updated":"2017-06-13T08:41:50.897Z","comments":true,"path":"2017/06/13/商城模块后台及APP流程/","link":"","permalink":"//www.wanwenxiu.com/2017/06/13/商城模块后台及APP流程/","excerpt":"马上要进入二期开发，需要把后台商城模块及APP中商城模块流程操作记录下来\n结尾附 详细订单操作流程图","text":"马上要进入二期开发，需要把后台商城模块及APP中商城模块流程操作记录下来 结尾附 详细订单操作流程图 商城进销存管理一: 库存管理1：库存信息搜索 2：批量入库： 商品编号+商品名称+商品规格+商品单价+入库数量+生产日期+有效期（天）+商品说明、所属项目+入库类型+采购人+入库备注 = 一条/多条 库存信息 +一条/多条入库记录 + 一条流水记录 3：批量出库： 所属项目+生产日期+有效期（天）+商品编号+（自动补全：商品名称+商品规格+商品单价+当前库存）+出库数量、出库用途+调度仓库+领取人+仓管员+出库备注 = 一条/多条库存信息 +一条/多条入库记录 + 一条流水记录 4：库存信息导出 5：查看、修改库存信息 6：单条库存出库: 选中一条库存信息，填写 调度仓库+出库用途+出库数量+领取人+仓管员+出库备注 = 一条/多条库存信息 +一条/多条入库记录 + 一条流水记录 7： 报损 选中一条库存信息，填写 报损数量+报损原因+操作员+备注 = 修改库存信息 + 一条出库信息 + 一条流水信息 +一条报损记录 8：设置上架数量 选中一条库存信息，商城管理不存在该商品信息 ，提示 “商城中未找到xx小区xx商品编号的商品信息,请先上传该商品”。存在该商品信息，输入 商城上架数量 = 修改商城管理中商品库存 9:删除库存信息 选中一条库存信息，点击删除，删除该库存信息 二:入库记录1: 搜索入库记录 2：导出入库记录 三:出库记录1: 搜索出库记录 2：导出出库记录 四:流水记录1: 搜索流水记录 2：导出流水记录 五:报损记录1: 搜索报损记录 六:过期提醒1: 搜索过期提醒 选择小区，列出所有即将在一个月之内过期的库存信息和已经过期的库存信息 商城管理一: 商品上传 1：输入：所属项目+生产日期+有效期（天）+商品编号查询是否存在该库存信息。不存在该库存信息，提示“该商品在库存中不存在”。存在该库存信息（自动补全 过期日期+商品名称+商品规格+商品进货价），输入商品售卖单价+配送类型（正常配送、大件配送）+是否高销量+是否高人气+一级分类+二级分类+是否活动展示+是否上架+是否缺货+是否夜间配送+商品图片（最多5张）+商品描述（富文本） = 一条商品信息 二: 商品管理1: 商品信息搜索 2.商品信息导出 3.设为夜间商品 选择一条或多条商品信息，点击设为夜间商品 = 修改商品信息 + 在夜间商品页面可查看 4:查看、修改 5：删除商品信息 选择一条商品信息，点击删除。删除该商品信息 6：查看评价 选择一条商品信息，点击查看评价，跳转至商品评价界面，可查看评价信息 三: 活动商品 搜索活动商品 查看修改 四: 缺货商品 搜索缺货商品 五: 夜间商品1搜索夜间商品 2查看修改 六:分类管理 搜索分类信息 添加一级分类 所属项目+一级分类+启用状态 = 一条分类信息 添加二级分类 所属项目 + 一级分类 +二级分类 +启用状态 +二级分类图片 = 一条二级分类信息 查看修改 删除 七:商城配置 增加欣社区APP内部图片 选择公司名称 + 配置区域（APP主界面以及快捷菜单栏广告轮播图、APP商城主界面中部区域广告轮播图+APP商城主界面一级分类图标）+配置名称+配置外部链接 +配置图片 = 一条商城配置信息 增加/修改欣社区商品夜间配送时间选择公司名称+配置类型（夜间配送开始时间、夜间配送结束时间）+时间类型（当日、次日） +配置时间 = 新增或修改该公司夜间配送时间（不存在新增，存在修改） 查看、修改配置信息 订单管理一: 订单管理 订单信息搜索 订单信息导出 一键收货 把所有超过3天未收货的订单一键处理为已完成订单 。修改订单状态 、修改配送记录状态、修改配送人配送信息、修改销售记录状态信息 切换接单模式 点击可切换指派模式和抢单模式。指派模式时：欣助手不能进行抢单 查看处理 订单状态为待发货时，点击进入订单详情界面。点击处理按钮。选择受理人（自动补全为登录人）+配送人 （接单状态为开启）=修改订单信息+产生配送记录。分配成功之后可提示是否打印订单信息。 打印订单 选择该小区一台打印机，点击确认。小区订单打印机开始打印订单信息 订单处理 文档结尾详细说明 二: 销售商品管理 搜索销售商品信息 导出销售商品信息 查看修改销售商品信息 删除销售商品信息 三: 配送人管理 搜索配送人信息 查看修改配送人信息 查看配送记录 选择一条配送人信息，跳转至配送记录列表。可查看该配送人配送详细记录 指派夜间负责人 选中一个配送人，点击指派夜间负责人。当时间是白天17点之前，指派夜间负责人，提示：现在不是夜间，不能指派夜间负责人。当时间是白天17:00-17:30时，指派夜间负责人，提示：还没到交班时间，请耐心等待一下。不选择一行信息记录，指派夜间负责人，提示：请单机选中一行，作为负责人。当帐号状态是禁用状态，指派夜间负责人，提示：该帐号状态为禁用，不能作为夜间值班人 接管值班 ？ 指派临时负责人 当管理员列表中没有临时管理员时，指派临时值班人，提示：暂没有查询到临时管理员。否则：弹出选择临时负责人页面，选择一个临时员，楼盘和用户名自动获取填入，点击确认，激活该负责人。临时管理员可以登录系统进行操作 导出值班负责人记录表 导出配送人员提成表 打印机设置一: 打印机管理 查看打印机 添加打印机 选择所属项目+打印机编号+打印机账号+打印机IP +HOSTNAME = 一条打印机信息 查看、修改打印机信息 删除打印机信息 投诉建议管理一: 商品投诉建议列表 搜素信息 查看处理 选择一条信息，点击处理。已经处理完成提示“已处理过了”。否则选择处理状态和反馈意见（默认：感谢您的宝贵意见，我们已经及时处理完成，给您带来不便我们深表歉意!） 进行处理 批量删除 选择一条或多条投诉建议信息，进行批量删除 二: 统计投诉建议 选择楼盘进行搜索，展示投诉统和建议数量统计 电子券管理一: 赠送电子券 选择项目 + 受赠人姓名 +受赠人电话 点击验证用户 ，不存在该用户提示，存在点击赠送电子券。输入电子券面额和赠送理由 进行赠送 二：电子券流水列表 搜素电子券流水 三：批量赠送电子券 选择项目，查询出该项目下所有业主，选择一个或多个进行批量赠送 订单流程图后台操作 订单状态 欣社区APP操作","raw":null,"content":null,"categories":[],"tags":[{"name":"商城","slug":"商城","permalink":"//www.wanwenxiu.com/tags/商城/"}]},{"title":"用VM+CentOS搭建java环境","slug":"VMware+CentOs+Jdk","date":"2017-05-12T02:20:00.000Z","updated":"2017-06-02T03:24:37.029Z","comments":true,"path":"2017/05/12/VMware+CentOs+Jdk/","link":"","permalink":"//www.wanwenxiu.com/2017/05/12/VMware+CentOs+Jdk/","excerpt":"公司需要搭建集群，以身试毒，我决定先在本地搭建一个Linux环境。先写下搭建的流程，以防万一。\n在开始之前，先把我需要用到的软件列出来  VMware CentOS JDK Tomcat  Rabbit  Redis  ELK，前面两个就不多描述了，毕竟下载个安装包安装应该不是什么难事。主要记录后续几种的安装与配置","text":"公司需要搭建集群，以身试毒，我决定先在本地搭建一个Linux环境。先写下搭建的流程，以防万一。 在开始之前，先把我需要用到的软件列出来 VMware CentOS JDK Tomcat Rabbit Redis ELK，前面两个就不多描述了，毕竟下载个安装包安装应该不是什么难事。主要记录后续几种的安装与配置 一 JDK进入Linux系统，打开命令行 。 1.输入 java -version 回车，查看系统是否默认安装jdk。 2.输入 rpm -qa | grep jdk，确定JDK详细版本，可能会显示下面的内容。 libgcj-4.1.2-42.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 3.输入 yum -y remove java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 卸载系统自带jdk 4.输入 rpm -ivh jdk-8u112-linux-x64.rpm 安装jdk 5.输入 vim /etc/profile 回车，配置环境变量。配置你自己的jdk安装目录。注意将路径换成你自己的安装路径。如果在命令行不好操作，可以将profile拷贝出来在修改。 export JAVA_HOME=/usr/java/jdk-1.6.0_22-fcs export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin 6.输入 source /etc/profile 修改该文件后要想马上生效。不然只能在下次重进此用户时才生效或者重启 二 Tomcat前提：由于我下载的是压缩包格式的，在安装前需要解压 1.输入tar -zxvf apache-tomcat-8.0.39.tar.gz 可以看到当前目录已经生成一个已经解压的目录 2.自动解压的目录名字很长，可以选择性修改名字 ，输入 cp -R apache-tomcat-8.0.39 tomcat ，-R 后面是当前文件夹名字 后面是要改的名字。 3.切换至tomcat的bin目录 ，输入./startup.sh 运行tomcat [root@localhost java]# cp -R apache-tomcat-8.0.39 apache8039 [root@localhost java]# ls apache8039 apache-tomcat-8.0.39 data default jdk1.8.0_112 latest [root@localhost java]# rm -rf apache-tomcat-8.0.39 [root@localhost java]# ls apache8039 data default jdk1.8.0_112 latest [root@localhost java]# cd apache8039/bin [root@localhost bin]# ./startup.sh Using CATALINA_BASE: /usr/java/apache8039 Using CATALINA_HOME: /usr/java/apache8039 Using CATALINA_TMPDIR: /usr/java/apache8039/temp Using JRE_HOME: /usr/java/jdk1.8.0_112 Using CLASSPATH: /usr/java/apache8039/bin/bootstrap.jar:/usr/java/apache8039/bin/tomcat-juli.jar Tomcat started. 4.启动成功，tomcat默认8080端口 ，访问http://ip:8080 查看是否成功,如果不成功，检查端口情况 输入netstat -ano|grep 8080 可以看到我的8080 已经被占用，此时你有两种方案，1修改8080端口 2修改tomcat默认端口，我采用第二种 [root@localhost bin]# netstat -ano|grep 8080 tcp6 0 0 127.0.0.1:8080 127.0.0.1:54527 TIME_WAIT timewait (41.96/0/0) [root@localhost bin]# netstat -ano|grep 80 tcp6 0 0 127.0.0.1:55272 127.0.0.1:8005 TIME_WAIT timewait (22.64/0/0) tcp6 0 0 127.0.0.1:8080 127.0.0.1:54527 TIME_WAIT timewait (22.70/0/0) tcp6 0 0 127.0.0.1:8009 127.0.0.1:54780 TIME_WAIT timewait (22.75/0/0) 5.找到tomcat的server.xml文件 ，修改里面的端口为80 。同样可以用命令行方式，也可以用图形化直接修改文件 6.再次启动tomcat服务，并访问 http://ip:80 ,如能够显示Tomcat的主页，则表示不需要进行任何操作了，如不能显示，则需要在Linux中开放防火墙的80端口。 7.vim /etc/sysconfig/iptables，写入开发80端口 # sample configuration for iptables service # you can edit this manually or use system-config-firewall # please do not ask us to add additional ports/services to this default configuration *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited COMMIT 8.之后重启防火墙,命令如下：service iptables restart 然后再次在浏览器中输入 http://ip:8080， 如果看到tomcat系统界面，说明安装成功，你可以进行下一步了。 [root@localhost sysconfig]# service iptables restart Redirecting to /bin/systemctl restart iptables.service Job for iptables.service failed. See &apos;systemctl status iptables.service&apos; and &apos;journalctl -xn&apos; for details. 9.停止Tomcat的命令是：/bin/shutdown.sh 三 Rabbit因为安装rabbitmq，必须依赖erlang。所以先安装erlang依赖 1.执行 wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm 2.执行 rpm -Uvh erlang-solutions-1.0-1.noarch.rpm 3.执行rpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc 主要添加了 /etc/yum.repo.d/erlang_solutions.repo [erlang-solutions] name=Centos $releasever - $basearch - Erlang Solutions baseurl=https://packages.erlang-solutions.com/rpm/centos/$releasever/$basearch gpgcheck=1 gpgkey=https://packages.erlang-solutions.com/rpm/erlang_solutions.asc enabled=1 4.执行sudo yum install erlang， 开始安装erlang ..... Transaction Summary ==================================================================================== Install 1 Package (+59 Dependent packages) Total size: 51 M Total download size: 51 M Installed size: 138 M Is this ok [y/d/N]: 5.输入y, 等待59个依赖包下载。 备注（ y：在线下载安装 d：只下载不安装 N：不安装 ）,等待安装完成Complete! 6.安装rabbit，我这里是直接下载的rabbitmq-server-generic-unix-3.6.8.tar文件，输入命令tar -xf rabbitmq-server-generic-unix-3.6.8.tar ,可以解压生成文件夹 7.开启rabbit服务 ，运行./rabbitmq-server -detached ,备注：-detached后台启动 8.运行./rabbitmq-plugins enable rabbitmq_management，插件方式启动rabbitmq 9.在浏览器运行 http://localhost:15672。账号密码都为guest。备注：账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用。在你登录之后可以创建其他账户以供外部访问。 10.如果你没有加载出，检查你的防火墙端口是否打开，可以参考上述tomcat开启80端口的方法 备注：安装完成之后可以写个小demo测试你的rabbitmq安装是否成功，可参考我的rabbitmq测试 demo 四 Redis简介：&lt;摘&gt; Redis是当前比较热门的NOSQL系统之一，它是一个key-value存储系统。和Memcache类似，但很大程度补偿了Memcache的不足，它支持存储的value类型相对更多，包括string、list、set、zset和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作。在此基础上，Redis支持各种不同方式的排序。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。 安装步骤： 1.首先上官网下载Redis压缩包，地址：http://redis.io/download 下载稳定版即可。我这边下载的是redis-3.2.5.tar.gz 2.将压缩包放入服务器中之后，输入tar -zxvf redis-3.2.5.tar.gz 可以看到当前目录已经生成一个已经解压的目录 3.cd 切换至解压的目录，输入make , 对Redis解压后文件进行编译 ...... Hint: It&apos;s a good idea to run &apos;make test&apos; ;) make[1]: Leaving directory `/usr/java/redis325/redis-3.2.5/src&apos; [root@localhost redis-3.2.5]# 4.执行ll,可以看到解压文件redis-3.2.5 中会有对应的src、conf等文件夹 [root@localhost redis-3.2.5]# ll total 204 -rw-rw-r--. 1 root root 78892 Oct 26 2016 00-RELEASENOTES -rw-rw-r--. 1 root root 53 Oct 26 2016 BUGS -rw-rw-r--. 1 root root 1805 Oct 26 2016 CONTRIBUTING -rw-rw-r--. 1 root root 1487 Oct 26 2016 COPYING drwxrwxr-x. 7 root root 4096 May 31 20:55 deps -rw-rw-r--. 1 root root 11 Oct 26 2016 INSTALL -rw-rw-r--. 1 root root 151 Oct 26 2016 Makefile -rw-rw-r--. 1 root root 4223 Oct 26 2016 MANIFESTO -rw-rw-r--. 1 root root 6834 Oct 26 2016 README.md -rw-rw-r--. 1 root root 46695 Oct 26 2016 redis.conf -rwxrwxr-x. 1 root root 271 Oct 26 2016 runtest -rwxrwxr-x. 1 root root 280 Oct 26 2016 runtest-cluster -rwxrwxr-x. 1 root root 281 Oct 26 2016 runtest-sentinel -rw-rw-r--. 1 root root 7606 Oct 26 2016 sentinel.conf drwxrwxr-x. 2 root root 4096 May 31 20:56 src drwxrwxr-x. 10 root root 4096 Oct 26 2016 tests drwxrwxr-x. 7 root root 4096 Oct 26 2016 utils [root@localhost redis-3.2.5]# 5.现在可以进行安装redis,执行命令make install，结果如下： [root@localhost src]# make install Hint: It&apos;s a good idea to run &apos;make test&apos; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL install [root@localhost src]# 6.到这一步安装就完成了，为了方便以后管理，我这里将src中几个可执行文件mkreleasehdr.sh，redis-check-aof，redis-server、redis-benchmark、redis-cli和redis.conf。拷贝到一个目录下。执行命令如下 [root@localhost redis-3.2.5]# mkdir bin [root@localhost redis-3.2.5]# mv redis.config /usr/java/redis325/redis-3.2.5/bin [root@localhost redis-3.2.5]# cd src [root@localhost redis-3.2.5]# mv mkreleasehdr.sh，redis-check-aof，redis-server、redis-benchmark、redis-cli /usr/java/redis325/redis-3.2.5/bin 7.前台启动redis ,执行命令./redis-server redis.conf 注意：这里直接执行Redis-server 启动的Redis服务，是在前台直接运行的(效果如图)，也就是说，执行完该命令后，如果Lunix关闭当前会话，则Redis服务也随即关闭。正常情况下，启动Redis服务需要从后台启动，并且指定启动配置文件。 [root@localhost bin]# ./redis-server redis.conf 10646:M 01 Jun 00:34:36.231 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.5 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 10646 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 10646:M 01 Jun 00:34:36.238 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 10646:M 01 Jun 00:34:36.238 # Server started, Redis version 3.2.5 10646:M 01 Jun 00:34:36.239 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect. 10646:M 01 Jun 00:34:36.250 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &apos;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&apos; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. 10646:M 01 Jun 00:34:36.250 * The server is now ready to accept connections on port 6379 8.Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程,即后台启动。打开redis.conf配置文件。 将daemonize no改为daemonize yes 9.Redis默认bind 127.0.0.1，即只可本机访问，如果需要进行外部可访问、打开redis.conf配置文件。 将bind 127.0.0.1改为# bind 127.0.0.1， 10.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭，如果需要进行有密码访问、打开redis.conf配置文件。 将requirepass foobared改为requirepass 123456 ,后者为访问密码 五 ELK","raw":null,"content":null,"categories":[],"tags":[{"name":"VMware","slug":"VMware","permalink":"//www.wanwenxiu.com/tags/VMware/"},{"name":"CentOS","slug":"CentOS","permalink":"//www.wanwenxiu.com/tags/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"//www.wanwenxiu.com/tags/JDK/"},{"name":"tomcat","slug":"tomcat","permalink":"//www.wanwenxiu.com/tags/tomcat/"},{"name":"rabbit","slug":"rabbit","permalink":"//www.wanwenxiu.com/tags/rabbit/"},{"name":"redis","slug":"redis","permalink":"//www.wanwenxiu.com/tags/redis/"},{"name":"elk","slug":"elk","permalink":"//www.wanwenxiu.com/tags/elk/"}]},{"title":"Android事件传递机制探索","slug":"Android事件传递机制探索","date":"2017-04-27T06:20:00.000Z","updated":"2017-05-15T03:11:53.694Z","comments":true,"path":"2017/04/27/Android事件传递机制探索/","link":"","permalink":"//www.wanwenxiu.com/2017/04/27/Android事件传递机制探索/","excerpt":"   总是不知道怎么写一篇文章的开头，总是删了又敲上，敲上又删了。就如学生时代写作文一样。如此反复，恍然大悟，这不是在写作文也不是在写给别人看，只是做简单的记录而已。犹豫什么呢？\n   在Android开发中，使用过很多控件（TextView Button View ListView Linearlayout …），设置过许多事件(单击、双击、长按、拖拽、滑动 …)。也肯定遇到过Listview的OnItemClickListener点击事件与Button的touch（或者click）事件冲突的问题。当然你肯定不会被难住。随手在度娘上一搜索，解决方法就出来了。但是你并没有深究为什么？都会用但是却不理解","text":"总是不知道怎么写一篇文章的开头，总是删了又敲上，敲上又删了。就如学生时代写作文一样。如此反复，恍然大悟，这不是在写作文也不是在写给别人看，只是做简单的记录而已。犹豫什么呢？ 在Android开发中，使用过很多控件（TextView Button View ListView Linearlayout …），设置过许多事件(单击、双击、长按、拖拽、滑动 …)。也肯定遇到过Listview的OnItemClickListener点击事件与Button的touch（或者click）事件冲突的问题。当然你肯定不会被难住。随手在度娘上一搜索，解决方法就出来了。但是你并没有深究为什么？都会用但是却不理解 来个草图。。。好寒酸好简陋 Android两大基础控件 主要分为：View和ViewGroup View:没有子控件的普通控件，例如 Textview、Button、ImageView… ViewGroup：可以存放子控件的控件，继承View。例如：ListView、Linearlayout… Android事件——MontionEvent 常见的动作常量： public static final int ACTION_DOWN = 0;单点触摸动作 public static final int ACTION_UP = 1;单点触摸离开动作 public static final int ACTION_MOVE = 2;触摸点移动动作 public static final int ACTION_CANCEL = 3;触摸动作取消 public static final int ACTION_OUTSIDE = 4;触摸动作超出边界 public static final int ACTION_POINTER_DOWN = 5;多点触摸动作 public static final int ACTION_POINTER_UP = 6;多点离开动作 以下是一些非touch事件 public static final int ACTION_HOVER_MOVE = 7; public static final int ACTION_SCROLL = 8; public static final int ACTION_HOVER_ENTER = 9; public static final int ACTION_HOVER_EXIT = 10; 平时使用最多的无非就是三种：ACTION_DOWN 按下 、ACTION_MOVE 拖动、ACTION_UP 抬起 所有的控件无非就是两个最基础的事件OnClick OnTouch，当然还有其他的事件如长按、单击、双击等，在这里是说最基本的事件。所有事件都是为了触发这两个事件。 Android事件传递函数一：View控件事件传递 主要分为两个方法：dispatchTouchEvent 和 onTouchEvent 。 @Override public boolean dispatchTouchEvent(MotionEvent ev) { return super.dispatchTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { return super.onTouchEvent(event); } 前者作用为分发，是事件传递入口！ 后者作用执行。可以看到两个方法都是返回Boolean类型。默认返回false。先简单的总结一下，后续再用demo演示 1.当有事件传递进来时，先执行dispatchTouchEvent方法，然后执行注册onTouch监听。接着执行onTouchEvent方法，在onTouchEvent中执行Onclick方法。 2.无论是dispatchTouchEvent方法还是onTouchEvent方法，只要有一个返回了true。则不继续向下分发执行。如果返回false，则代表继续像下执行。例如：如果dispatchTouchEvent在执行OnTouch事件时返回了True,那么就不再分发给onTouchEvent事件，onTouchEvent方法就不会再执行，当然Onclick事件就更不会执行了。 如果你没有看懂，我们可以写一个小程序看打印日志，就可以看到执行顺序了。 /** * 作者：wwx on 2017/4/27 0027 11:23 * 邮箱：wanwenxiu0709@foxmail.com * 描述：探索Android事件传递机制 */ public class TouchEventAvtivityActivity extends Activity{ @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.touchevent_main_activity); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: Activity ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: Activity ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: Activity ACTION_UP&quot;); break; default: break; } return super.dispatchTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;onTouchEvent: Activity ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.d(&quot;geek&quot;, &quot;onTouchEvent: Activity ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;onTouchEvent: Activity ACTION_UP&quot;); break; default: break; } return super.onTouchEvent(event); } } 新建Activity,复写 dispatchTouchEvent 和 onTouchEvent 方法。运行程序之后，点击屏幕。查看日志 04-28 11:17:02.728 6961-6961/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-28 11:17:02.738 6961-6961/wwx.toucheventdemo D/geek: onTouchEvent: Activity ACTION_DOWN 04-28 11:17:02.888 6961-6961/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_MOVE 04-28 11:17:02.888 6961-6961/wwx.toucheventdemo D/geek: onTouchEvent: Activity ACTION_MOVE 04-28 11:17:02.928 6961-6961/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 04-28 11:17:02.928 6961-6961/wwx.toucheventdemo D/geek: onTouchEvent: Activity ACTION_UP 可以看运行顺序，dispatchTouchEvent 比 onTouchEvent 先执行，因为我没有改dispatchTouchEvent返回值，返回false，所以onTouchEvent执行了。现在我改dispatchTouchEvent返回值为true，将上文中 return super.dispatchTouchEvent(ev); 改为 return true ，看看运行效果。 04-28 11:34:17.218 7181-7181/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-28 11:34:17.258 7181-7181/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 可以看到由于dispatchTouchEvent return true，即已经自己消费了，就不会分发onTouchEvent方法。 上图是直接在Activity中测试的，现在我们写个自定义View-TouchEventTextView，复写TouchEventTextView的dispatchTouchEvent 方法和 onTouchEvent方法，最后再Activty中设置TouchEventTextView的点击时间和触摸事件。做进一步观察。测试代码如下： /** * 作者：wwx on 2017/4/28 17:33 * 邮箱：wanwenxiu0709@foxmail.com * 描述：自定义TextView 实现dispatchTouchEvent和dispatchTouchEvent方法 */ @SuppressLint(&quot;AppCompatCustomView&quot;) public class TouchEventTextView extends TextView{ public TouchEventTextView(Context context) { super(context); } public TouchEventTextView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public TouchEventTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } public TouchEventTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: TouchEventTextView ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: TouchEventTextView ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: TouchEventTextView ACTION_UP&quot;); break; default: break; } return super.dispatchTouchEvent(event); } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;onTouchEvent: TouchEventTextView ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.d(&quot;geek&quot;, &quot;onTouchEvent: TouchEventTextView ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;onTouchEvent: TouchEventTextView ACTION_UP&quot;); break; default: break; } return super.onTouchEvent(event); } } 在上文中的Activity中，实现TouchEventTextView的Onclick和OnTouch事件 TouchEventTextView tv = (TouchEventTextView) findViewById(R.id.tv); tv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(&quot;geek&quot;, &quot;onClick点击事件: TouchEventTextView&quot;); } }); tv.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { Log.d(&quot;geek&quot;, &quot;onTouch点击事件: TouchEventTextView +&quot;+event.getAction()); return false; } }); 运行之后，点击Textview按钮，可以看到运行日志为: 04-29 10:20:53.266 12732-12732/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-29 10:20:53.266 12732-12732/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_DOWN 04-29 10:20:53.266 12732-12732/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +0 04-29 10:20:53.266 12732-12732/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_DOWN 04-29 10:20:53.336 12732-12732/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 04-29 10:20:53.336 12732-12732/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_UP 04-29 10:20:53.336 12732-12732/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +1 04-29 10:20:53.336 12732-12732/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_UP 04-29 10:20:53.336 12732-12732/wwx.toucheventdemo D/geek: onClick点击事件: TouchEventTextView 可以看到： 1.按下手指时，由于Activity的dispatchTouchEvent事件 return false，所以继续分发给TouchEventTextView的dispatchTouchEvent事件，并进入TouchEventTextView的OnTouch方法，当然可以看到打印的事件是0–ACTION_DOWN–按下操作。然后TouchEventTextView继续执行onTouchEvent事件。 2.手指抬起时,也一样套路，不过多了一步，最后执行TouchEventTextView的Onclick事件。 3.我们可以看到，dispatchTouchEvent是Activity和TouchEventTextView都执行了，上面我们说了dispatchTouchEvent是事件的入口。而onTouchEvent只有TouchEventTextView执行了。 4.还可以得到一个结论，在onClick事件和onTouch事件同时设置时，是onTouch事件先执行。 那如果我点击TouchEventTextView的时候，不想执行TouchEventTextView的任何事件怎么办呢？我们只需要在activity层的dispatchTouchEvent设置 return true即可，这样就不会像下面的控件分发，由Activity自己消费。 见日志： 04-29 10:38:37.816 7471-7471/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-29 10:38:37.916 7471-7471/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 如果是不想执行TouchEventTextVie的onTouch事件，将TouchEventTextView中的dispatchTouchEvent事件设置 return true,点击效果为： 04-29 10:41:37.686 9622-9622/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-29 10:41:37.686 9622-9622/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_DOWN 04-29 10:41:37.776 9622-9622/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 04-29 10:41:37.776 9622-9622/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_UP 如果是不想执行TouchEventTextVie的onClick事件，将TouchEventTextView中的onTouchEvent事件设置 return true,点击效果为： 04-29 10:43:21.486 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-29 10:43:21.486 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_DOWN 04-29 10:43:21.486 12119-12119/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +0 04-29 10:43:21.486 12119-12119/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_DOWN 04-29 10:43:21.506 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_MOVE 04-29 10:43:21.506 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_MOVE 04-29 10:43:21.506 12119-12119/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +2 04-29 10:43:21.506 12119-12119/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_MOVE 04-29 10:43:21.586 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 04-29 10:43:21.586 12119-12119/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_UP 04-29 10:43:21.586 12119-12119/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +1 04-29 10:43:21.586 12119-12119/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_UP 从中也可以得到一个结论：onTouch事件时依附于dispatchTouchEvent事件，onclick事件是依附于onTouchEvent事件。 二：ViewGroup控件事件传递 相对于普通view来说，除了一样有dispatchTouchEvent方法和onTouchEvent方法之外，还有一个方法是onInterceptTouchEvent方法，这个方法是控制是否拦截，并且是dispatchTouchEvent之后才执行，且是存在ViewGroup方法中。同样也是Boolean类型控制是否向下分发。详见代码： 新建类TouchEventLinearLayout，继承LinearLayout布局。实现dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent三个方法。 /** * 作者：wwx on 2017/4/29 0029 11:03 * 邮箱：wanwenxiu0709@foxmail.com * 描述：自定义线性布局 */ public class TouchEventLinearLayout extends LinearLayout { public TouchEventLinearLayout(Context context) { super(context); } public TouchEventLinearLayout(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public TouchEventLinearLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public TouchEventLinearLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: TouchEventLinearLayout ACTION_DOWN&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;dispatchTouchEvent: TouchEventLinearLayout ACTION_UP&quot;); break; default: break; } return super.dispatchTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;onInterceptTouchEvent: TouchEventLinearLayout ACTION_DOWN&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;onInterceptTouchEvent: TouchEventLinearLayout ACTION_UP&quot;); break; default: break; } return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(&quot;geek&quot;, &quot;onTouchEvent: TouchEventLinearLayout ACTION_DOWN&quot;); break; case MotionEvent.ACTION_UP: Log.d(&quot;geek&quot;, &quot;onTouchEvent: TouchEventLinearLayout ACTION_UP&quot;); break; default: break; } return super.onTouchEvent(event); } } 创建布局文件touchevent_linearlayout_activity。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;wwx.toucheventdemo.TouchEventLinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;400dp&quot;&gt; &lt;wwx.toucheventdemo.TouchEventTextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:text=&quot;文字&quot;/&gt; &lt;/wwx.toucheventdemo.TouchEventLinearLayout&gt; &lt;/LinearLayout&gt; Activity不变，运行点击文字按钮，可以看到运行效果 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_DOWN 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventLinearLayout ACTION_DOWN 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: onInterceptTouchEvent: TouchEventLinearLayout ACTION_DOWN 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_DOWN 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +0 04-29 11:20:50.416 18184-18184/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_DOWN 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: Activity ACTION_UP 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventLinearLayout ACTION_UP 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: onInterceptTouchEvent: TouchEventLinearLayout ACTION_UP 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: dispatchTouchEvent: TouchEventTextView ACTION_UP 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: onTouch点击事件: TouchEventTextView +1 04-29 11:20:50.496 18184-18184/wwx.toucheventdemo D/geek: onTouchEvent: TouchEventTextView ACTION_UP 可以看到运行顺序，Activity-&gt;TouchEventLinearLayout-&gt;TouchEventTextView，Android中事件传递是从ViewGroup传递到View的，而不是反过来传递的。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"//www.wanwenxiu.com/tags/Android/"},{"name":"dispatchTouchEvent","slug":"dispatchTouchEvent","permalink":"//www.wanwenxiu.com/tags/dispatchTouchEvent/"},{"name":"onTouchEvent","slug":"onTouchEvent","permalink":"//www.wanwenxiu.com/tags/onTouchEvent/"},{"name":"onInterceptTouch","slug":"onInterceptTouch","permalink":"//www.wanwenxiu.com/tags/onInterceptTouch/"}]},{"title":"评论系统比较-网易云跟帖集成","slug":"disqus_config","date":"2017-04-17T07:20:00.000Z","updated":"2017-05-15T03:13:17.357Z","comments":true,"path":"2017/04/17/disqus_config/","link":"","permalink":"//www.wanwenxiu.com/2017/04/17/disqus_config/","excerpt":"不要在意细节不要在意文笔——毕竟像我这种懒癌晚期的程序猿！！！终于要开始记录了\n这是现在的丑样，看看别人的网站，评论分享玩的飞起！！我讲真不知道是怎么把那些功能添加进来的\n第六感告诉我，应该不难。仔细看了主体下的配置文件，里面有这么一段话：\n是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key 若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: false\n看描述好像很简单，接下来就拿起键盘干….","text":"不要在意细节不要在意文笔——毕竟像我这种懒癌晚期的程序猿！！！终于要开始记录了 这是现在的丑样，看看别人的网站，评论分享玩的飞起！！我讲真不知道是怎么把那些功能添加进来的 第六感告诉我，应该不难。仔细看了主体下的配置文件，里面有这么一段话： 是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key 若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论 duoshuo: false 看描述好像很简单，接下来就拿起键盘干…. 方案一 多说:多说项目将于2017年6月1日正式关停服务 so 换个方案 方案二 disqusdisqus是hexo原生支持的一款评论插件。但是是国外的，纯英文界面不太友好。一番折腾之后发现，我并不是十分倾向于disqus。 方案三 网易云跟帖终极方案-网易云，这是16年6月份推出的产品。相比较于畅言，最大的优点就是将站点进行不用备案。当然目前我的站点是进行备案的~^_^~ 注册网易云跟帖账号，注册完成之后点击页面右上角-后台管理 填写基本信息，站点信息 获取代码 → WEB代码 ，其中代码中productKey：xxxxxxx，对应的就是我们唯一的key。 打开主题在你电脑的文件目录 ，例如我的是 E:\\hexo\\themes\\yilia\\layout\\_partial\\post，新建文件 netease.ejs ,复制如下代码 12345678910111213141516&lt;!-- 网易云跟帖评论插件通用代码 --&gt;&lt;div class=\"netease\"&gt; &lt;div id=\"cloud-tie-wrapper\" class=\"cloud-tie-wrapper\"&gt;&lt;/div&gt; &lt;script src=\"https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js\"&gt;&lt;/script&gt; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: \"\", productKey: \"&lt;%= theme.gentie_productKey %&gt;\", target: \"cloud-tie-wrapper\" &#125;; var yunManualLoad = true; Tie.loader(\"aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s\", true); &lt;/script&gt;&lt;/div&gt;&lt;!-- 网易云跟帖代码结束 --&gt; 找到对应 themes\\yilia\\layout\\_partial 文件目录，找到article.ejs文件 ，加入如下代码 1234567&lt;% if (!index)&#123; %&gt; &lt;% if (theme.gentie_productKey &amp;&amp; post.comments)&#123; %&gt; &lt;%- partial('post/netease') %&gt; &lt;% &#125; else &#123; %&gt; &lt;div class=\"netease\"&gt;&lt;/div&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 6.在yilia主题的配置文件_config.yml中加入以下配置： gentie_productKey: 你的网易云跟帖生成的productKey 配置就结束了，本地清理clear 部署g，运行hexo server，心情美美哒等待评论的功能出现 想说一直清理运行了很多遍，都没有出来评论的功能好吗？？？？ what happened！！！ 好了，因为本地运行是不会显示评论框滴，需要部署至正式环境~~~~ thanks xelengo wwx 2017.04.18","raw":null,"content":null,"categories":[],"tags":[{"name":"评论","slug":"评论","permalink":"//www.wanwenxiu.com/tags/评论/"},{"name":"disqus","slug":"disqus","permalink":"//www.wanwenxiu.com/tags/disqus/"},{"name":"网易云跟帖","slug":"网易云跟帖","permalink":"//www.wanwenxiu.com/tags/网易云跟帖/"},{"name":"多说","slug":"多说","permalink":"//www.wanwenxiu.com/tags/多说/"}]},{"title":"关于me","slug":"aboutme","date":"2017-04-10T02:20:00.000Z","updated":"2017-04-14T07:34:58.330Z","comments":true,"path":"2017/04/10/aboutme/","link":"","permalink":"//www.wanwenxiu.com/2017/04/10/aboutme/","excerpt":"","text":"I am a slow walker,but I never walk backwards. 我走得很慢，但是我从来不会后退。","raw":null,"content":null,"categories":[],"tags":[{"name":"简介","slug":"简介","permalink":"//www.wanwenxiu.com/tags/简介/"}]}]}